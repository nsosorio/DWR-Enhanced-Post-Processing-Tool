"use strict";

const { domSymbolTree } = require("jsdom/lib/jsdom/living/helpers/internal-constants");
const { SVG_NS } = require("jsdom/lib/jsdom/living/helpers/namespaces");
const { mixin } = require("jsdom/lib/jsdom/utils");
const SVGAnimatedString = require("jsdom/lib/jsdom/living/generated/SVGAnimatedString");
const ElementImpl = require("jsdom/lib/jsdom/living/nodes/Element-impl").implementation;
const ElementCSSInlineStyleImpl = require("jsdom/lib/jsdom/living/nodes/ElementCSSInlineStyle-impl").implementation;
const GlobalEventHandlersImpl = require("jsdom/lib/jsdom/living/nodes/GlobalEventHandlers-impl").implementation;
const HTMLAndSVGElementSharedImpl = require("jsdom/lib/jsdom/living/nodes/HTMLAndSVGElementShared-impl").implementation;

class SVGElementImpl extends ElementImpl {
  constructor(args, privateData) {
    super(args, privateData);
    this._initHTMLAndSVGElement();
    this._initElementCSSInlineStyle();
    this._initGlobalEvents();
  }

  get className() {
    return SVGAnimatedString.createImpl([], {
      element: this,
      attribute: "class"
    });
  }

  get ownerSVGElement() {
    let e = domSymbolTree.parent(this);
    while (e && e.namespaceURI === SVG_NS) {
      if (e.localName === "svg") {
        return e;
      }
      e = domSymbolTree.parent(e);
    }

    return null;
  }

  get viewportElement() {
    // TODO: <symbol>/<use> may make this different from ownerSVGElement.
    return this.ownerSVGElement;
  }
}

SVGElementImpl.attributeRegistry = new Map();

mixin(SVGElementImpl.prototype, ElementCSSInlineStyleImpl.prototype);
mixin(SVGElementImpl.prototype, GlobalEventHandlersImpl.prototype);
mixin(SVGElementImpl.prototype, HTMLAndSVGElementSharedImpl.prototype);

exports.implementation = SVGElementImpl;
