"use strict";

const HTMLElementImpl = require("jsdom/lib/jsdom/living/nodes/HTMLElement-impl").implementation;
const MouseEvent = require("jsdom/lib/jsdom/living/generated/MouseEvent");
const { domSymbolTree } = require("jsdom/lib/jsdom/living/helpers/internal-constants");
const NODE_TYPE = require("jsdom/lib/jsdom/living/node-type");
const { isLabelable, isDisabled } = require("jsdom/lib/jsdom/living/helpers/form-controls");

function sendClickToAssociatedNode(node) {
  node.dispatchEvent(MouseEvent.createImpl([
    "click",
    {
      bubbles: true,
      cancelable: true,
      view: node.ownerDocument ? node.ownerDocument.defaultView : null,
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      button: 0,
      detail: 1,
      relatedTarget: null
    }
  ]));
}

class HTMLLabelElementImpl extends HTMLElementImpl {
  get control() {
    if (this.hasAttribute("for")) {
      const forValue = this.getAttribute("for");
      if (forValue === "") {
        return null;
      }
      const root = this.getRootNode();
      for (const descendant of domSymbolTree.treeIterator(root)) {
        if (descendant.nodeType === NODE_TYPE.ELEMENT_NODE &&
          descendant.getAttribute("id") === forValue) {
          return isLabelable(descendant) ? descendant : null;
        }
      }
      return null;
    }
    for (const descendant of domSymbolTree.treeIterator(this)) {
      if (isLabelable(descendant)) {
        return descendant;
      }
    }
    return null;
  }

  get form() {
    const node = this.control;
    if (node) {
      return node.form;
    }
    return null;
  }

  _activationBehavior() {
    const node = this.control;
    if (node && !isDisabled(node)) {
      sendClickToAssociatedNode(node);
    }
  }
}

module.exports = {
  implementation: HTMLLabelElementImpl
};
